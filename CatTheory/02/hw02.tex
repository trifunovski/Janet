\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{times}
\usepackage{amsmath,proof,amsthm,amssymb}

%% part of a problem
\newcommand{\task}[2]
  {\bigskip \noindent
   {\bf Task #1} (#2\%).}

\newcommand{\ectask}[1]
  {\bigskip \noindent
   {\bf Task #1} (Extra Credit).}

\newcommand{\ms}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\irl}[1]{\texttt{#1}}
\newcommand{\ttt}[1]{\texttt{#1}}

\newcommand{\asc}[1]{\mbox{\tt #1}}

%% concrete syntax
\newcommand{\clet}[3]{\asc{let}\,#1\,\asc{be}\,#2\,\asc{in}\,#3}
\newcommand{\ccon}[2]{#1 \ \mbox{\textasciicircum} \ #2}
\newcommand{\cstr}[1]{\asc{"#1"}}

%% de Bruijn
\newcommand{\cdlet}[2]{\clet{\cdot}{#1}{#2}}
\newcommand{\db}[1]{\ensuremath{\ulcorner #1 \urcorner}}

%% abstract syntax
\newcommand{\anum}[1]{\ms{num}[#1]}
\newcommand{\astr}[1]{\ms{str}[#1]}
\newcommand{\anumn}{\anum{n}}
\newcommand{\astrs}{\astr{s}}
\newcommand{\aplus}[2]{\ms{plus}(#1, #2)}
\newcommand{\acat}[2]{\ms{cat}(#1, #2)}
\newcommand{\alet}[3]{\ms{let}(#1, #2.#3)}

%% de Bruijn
\newcommand{\adnumn}{\ms{\overline{num}}[n]}
\newcommand{\adstrs}{\ms{\overline{str}}[s]}
\newcommand{\adplus}[2]{\ms{\overline{plus}}(#1, #2)}
\newcommand{\adcat}[2]{\ms{\overline{cat}}(#1, #2)}
\newcommand{\adlet}[2]{\ms{\overline{let}}(#1, #2)}

\newcommand{\tr}[2]{\ensuremath{#1 \, \rhd \, #2}}
\newcommand{\dbsub}[4]{\ensuremath{\{#1 \leftarrow #2\}\, #3\: = \: #4}}

\newcommand{\dom}[1]{\mbox{dom}(#1)}

\newcommand{\aeq}[2]{\ensuremath{#1 \, \equiv_\alpha \, #2}}
\newcommand{\liesapart}[2]{\ensuremath{#1 \, \# \, #2}}
\newcommand{\swap}[3]{\ensuremath{[#1 \leftrightarrow #2] #3}}

\newcommand{\EXP}[0]{$\mathcal{L}$\{\texttt{num},\texttt{str}\}}

%% typing
\newcommand{\typeof}[3]{\ensuremath{#1 \, \vdash \, #2 : #3}}
\newcommand{\tnum}{\ms{num}}
\newcommand{\tstr}{\ms{str}}

%% reduction
\newcommand{\steps}[2]{\ensuremath{#1 \mapsto #2}}
\newcommand{\val}[1]{\ensuremath{#1 \, \ms{value}}}
\newcommand{\sub}[3]{\ensuremath{[#2 / #1]\ #3}}
\newcommand{\subeq}[4]{\sub{#1}{#2}{#3} = #4}

\title{COMP 321: Principles of Programming Languages, Spring 2014 \\
       Assignment 2: Type safety, Implementing Semantics}
\date{Out: Thursday, February 6, 2014 \\
Due: Thursday, February 13, 2014, 2:40 PM}

\begin{document}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}

\maketitle

In this assignment, you will do a first type safety proof, and you will
implement a typechecker (the static semantics) and evaluator (the
dynamic semantics) for \EXP.

The written portion should be handed in in class.
The programming portion should be copied to your handin directory on WesFiles.


\section{Type Safety}

\newcommand{\lettwo}[5]{\ensuremath{\mathsf{let2}(#1,#2,#3.#4.#5)}}

Suppose we extended \EXP with a primitive two-binding \verb|let|:
\begin{verbatim}
let x be 7 
    y be 8
 in
    x + y
\end{verbatim}
would evaulate to 15.  \verb|x| and \verb|y| are both only in scope in
the body of the \verb|let|, not in each other.  As an ABT, we write
\lettwo{e_1}{e_2}{x}{y}{e_3} for \verb|let x be e1 y be e2 in e3|.

Here is a typing rule:
\[
\infer[\texttt{typing-let2}]{\typeof{\Gamma}{\lettwo{e_1}{e_2}{x}{y}{e_3}}{\tau_3}}
      {\typeof{\Gamma}{e_1}{\tau_1} & 
        \typeof{\Gamma}{e_2}{\tau_2} & 
        \typeof{\Gamma, x : \tau_1 , y : \tau_2}{e_3}{\tau_3}}
\]

\task{1}{15} Give dynamic semantics rules for
\lettwo{e_1}{e_2}{x}{y}{e_3}.  Your semantics should evaluate the two
bindings in left-to-right order, and should be call-by-value.  

\task{2}{15} Recall the progress theorem:
\begin{quote}
For all $e,\tau$, if $\typeof{\cdot}{e}{\tau}$ then either $e \:
\mathsf{value}$ or there exists an $e'$ such that $\steps{e}{e'}$.
\end{quote}
Here, the notation \typeof{\cdot}{e}{\tau} means that $e$ has type
$\tau$ in the empty context. 

Progress is proved by rule induction on the derivation of
$\typeof{\cdot}{e}{\tau}$.  Prove the case of progress for the typing
rule \texttt{typing-let2} for {\lettwo{e_1}{e_2}{x}{y}{e_3}}.

\task{3}{15} Recall the preservation theorem:
\begin{quote}
For all $e,e',\tau$, if \steps{e}{e'} and $\typeof{\cdot}{e}{\tau}$ then \typeof{\cdot}{e'}{\tau}.
\end{quote}
Preservation is proved by rule induction on \steps{e}{e'}.  Prove the
cases of preservation for your dynamic semantics rules from Task 1.

You may use the following lemmas:
\begin{itemize}
\item Inversion of typing:  For all $e_1,e_2,x,y,e_3,\tau$, 
if $\typeof{\cdot}{\lettwo{e_1}{e_2}{x}{y}{e_3}}{\tau}$ then 
there exist $\tau_1$ and $\tau_2$ such that 
$\typeof{\cdot}{e_1}{\tau_1}$
and $\typeof{\cdot}{e_2}{\tau_2}$
and $\typeof{x : \tau_1 , y : \tau_2}{e_3}{\tau}$.

\item Weakening: For all $\Gamma,e,\tau,\tau_1,x$, if \typeof{\Gamma}{e}{\tau}
  and $x \not \in \Gamma$ then \typeof{\Gamma,x:\tau_1}{e}{\tau}.


\item Substitution:
For all $\Gamma,e,x,\tau,\tau'$ , 
if \typeof{\Gamma,x:\tau}{e'}{\tau'} and \typeof{\Gamma}{e}{\tau}
then \typeof{\Gamma}{\sub{x}{e}{e'}}{\tau'}
\end{itemize}


\section{Implementing ABTs}

In homework 1, you implemented the syntax for \EXP.  This was a bit
tricky, because you needed to remember to freshen variables (generate a
new name and swap it in) at the right time.  We can make programming
with ABTs less error-prone by encapsulating this freshening in a
separate module.  The signature for such a module is as follows:

\begin{verbatim}
signature EXP = 
sig
    structure N : NAME;

    (* real type of expressions *)
    type exp;

    (* we expose an exp one level as a datatype *)
    datatype exp1 = 
        Var of N.name
      | Number of int
      | String of string
      | Plus of exp * exp
      | Cat of exp * exp
      | Let of exp * N.name * exp;

    (* any bound name you get back from show is fresh *)
    val show : exp -> exp1;

    val hide : exp1 -> exp;
        
    val equal : exp * exp -> exp;
end
\end{verbatim}

The substructure \ttt{N} provides an implementation of names. 

The representation type \ttt{exp} is hidden, so the implementation of
this module can choose any type it wants.  To inspect an ABT, you use
the \ttt{show} function, which exposes one level of the tree as the
concrete datatype \ttt{exp1}. (In \ttt{exp1} the subterms have type
\ttt{exp}, so you can't see any further without calling \ttt{show}
again.) In order to create an ABT, you must make an \ttt{exp1} (possibly
containing some \ttt{exp}s you have around) and \ttt{hide} it.  The key
point is that \emph{when you \ttt{show} an \ttt{exp} representing a
  \ttt{Let} term, an implementation must return a fresh name.}  The fact
that there is no way to take apart an ABT besides calling \verb|show|
means that you can never forget to freshen a bound variable.  

\task{1}{10} Implement a module with signature \verb|EXP| in the file
\verb|exp-named.sml| by adapting your code from Homework 1.  In your
implementation, \verb|exp| and \verb|exp1| should actually be the same
type, and \verb|hide| does not need to do anything.  \verb|show| should
freshen bound names using a function like \verb|swapExp| from Homework 1.
Note that your implementation of substitution from Homework 1 does not
go in this file; you will use that later.  

You can test your code using the function \verb|Top.loop_print|
described in the next section.  You should be able to see the variables
being freshened when it prints a term, because it prints using
\verb|show|; for example:

\begin{verbatim}
- Top.loop_print();

EXP>let x be 4 in x + x end;
let x1517 be 4 in
    x1517 + x1517
end;

EXP>let x be 4 in x + x end;
let x1820 be 4 in
    x1820 + x1820
end;
\end{verbatim}

\section{Implementing the Static and Dynamic Semantics}

\begin{figure}

\[
\begin{array}{c}
\infer{\typeof{\Gamma, x : \tau, \Gamma'}{x}{\tau}}{} \\
\\
\infer{\typeof{\Gamma}{\anumn}{\tnum}}{}
\qquad
\infer{\typeof{\Gamma}{\astrs}{\tstr}}{}\\
\\
\infer{\typeof{\Gamma}{\aplus{e_1}{e_2}}{\tnum}}{\typeof{\Gamma}{e_1}{\tnum} & \typeof{\Gamma}{e_2}{\tnum}}
\qquad
\infer{\typeof{\Gamma}{\acat{e_1}{e_2}}{\tstr}}{\typeof{\Gamma}{e_1}{\tstr} & \typeof{\Gamma}{e_2}{\tstr}} \\
\\
\infer{\typeof{\Gamma}{\alet{e_1}{x}{e_2}}{\tau_2}}{\typeof{\Gamma}{e_1}{\tau_1} & \typeof{\Gamma, x : \tau_1}{e_2}{\tau_2}}
\end{array}
\]

\hrule
\caption{Static semantics for \EXP.}
\label{fig:static-semantics}
\end{figure}

\begin{figure}

\[
\begin{array}{c}
\infer{\steps{\aplus{\anum{m}}{\anum{n}}}{\anum{p}}}{\mathsf{add}(m,n,p)}
\qquad
\infer{\steps{\acat{\astr{s}}{\astr{t}}}{\astr{u}}}{\mathsf{append}(s,t,u)} \\
\\
\infer{\steps{\aplus{e_1}{e_2}}{\aplus{e_1'}{e_2}}}{\steps{e_1}{e_1'}}
\qquad
\infer{\steps{\aplus{e_1}{e_2}}{\aplus{e_1}{e_2'}}}{\val{e_1} & \steps{e_2}{e_2'}}\\
\\
\infer{\steps{\acat{e_1}{e_2}}{\acat{e_1'}{e_2}}}{\steps{e_1}{e_1'}}
\qquad
\infer{\steps{\acat{e_1}{e_2}}{\acat{e_1}{e_2'}}}{\val{e_1} & \steps{e_2}{e_2'}}\\
\\
\infer{\steps{\alet{e_1}{x}{e_2}}{\alet{e_1'}{x}{e_2}}}{\steps{e_1}{e_1'}}
\qquad
\infer{\steps{\alet{e_1}{x}{e_2}}{\sub{x}{e_1}{e_2}}}{\val{e_1}}\\
\\
\end{array}
\]

\hrule
\caption{Dynamic semantics for \EXP.}
\label{fig:dynamic-semantics}
\end{figure}

\begin{figure}

\[
\begin{array}{c}
\infer{\subeq{x}{e}{x}{e}}{}
\qquad
\infer{\subeq{x}{e}{y}{y}}{{x} \neq {y}}\\
\\
\infer{\subeq{x}{e}{\anumn}{\anumn}}{}
\qquad
\infer{\subeq{x}{e}{\astrs}{\astrs}}{}\\
\\
\infer{\subeq{x}{e}{\aplus{e_1}{e_2}}{\aplus{e_1'}{e_2'}}}{\subeq{x}{e}{e_1}{e_1'} & \subeq{x}{e}{e_2}{e_2'}}
\qquad
\infer{\subeq{x}{e}{\acat{e_1}{e_2}}{\acat{e_1'}{e_2'}}}{\subeq{x}{e}{e_1}{e_1'} & \subeq{x}{e}{e_2}{e_2'}}\\
\\
\infer{\subeq{x}{e}{\alet{e_1}{x}{e_2}}{\alet{e_1'}{x}{e_2}}}{\subeq{x}{e}{e_1}{e_1'}}
\qquad
\infer{\subeq{x}{e}{\alet{e_1}{y}{e_2}}{\alet{e_1'}{y}{e_2'}}}{\subeq{x}{e}{e_1}{e_1'} & {x}\neq{y} & {y}\not\in{e} & \subeq{x}{e}{e_2}{e_2'}}
\end{array}
\]

\hrule
\caption{Substitution for \EXP.}
\label{fig:exp-sub}
\end{figure}

In Figure~\ref{fig:static-semantics}, we have included the static
semantics of \EXP.  You can find a discussion of this typing judgement
in PFPL Chapter 4.  Note that we called the types \verb|nat| and
\verb|string| rather than \verb|num| and \verb|str| in class.
\verb|cat(e1,e2)| is what we wrote as \verb|e1 ^ e2|.  

\task{1}{20} Program a typechecker for \EXP.  We have provided a stub
for you in \ttt{check.sml}, which should result in a structure matching
the signature \ttt{CHECK} in \ttt{check-sig.sml}.  We have set things up
so that your type checker is a functor parameterized by a structure
matching \ttt{EXP}.  You will need to choose a representation for
contexts $\Gamma$; don't worry about efficiency for this assignment.  

\bigskip

In Figure~\ref{fig:dynamic-semantics}, we have included the dynamic
semantics of \EXP. You can find a discussion of this transition system
judgement in PFPL Chapter 5. In Figure~\ref{fig:exp-sub} we have
included the definition of substitution on \EXP\ terms (this is just a
specialization of the definition in PFPL Chapter 1).

\task{2}{20} Implement the dynamic semantics for \EXP.
Once again, we have provided stubs for you in \ttt{step.sml}, which
should result in a structure matching the signature \ttt{STEP} in
\ttt{step-sig.sml}, and your evaluator should be a functor parameterized
by the actual implementation of \ttt{EXP}.  

To implement these dynamic semantics, you will need to implement
substitution.  This should be similar to your implementation from
Homework 1, except, because you are implementing it from the ``outside''
of the \verb|EXP| interface, you don't need to explicitly freshen
names---\verb|show| does that for you.  The freshness condition means
that the conditions on the rule for substituting into an abstractor are
always satisfied.  

\bigskip

In the support code, we have supplied a parser for a concrete syntax for
\EXP\ as well as several functions to help you test your code (see the
\verb|Top| module)

\begin{verbatim}
    val loop_print : unit -> unit (* just print the same expression back *)
    val loop_type  : unit -> unit (* just type check *)
    val loop_eval  : unit -> unit (* type check and show the final value *)
    val loop_step  : unit -> unit (* type check and show all steps of evaluation *)

    (* similar, but read a .exp source file *)
    val file_print : string -> unit
    val file_type  : string -> unit
    val file_eval  : string -> unit
    val file_step  : string -> unit
\end{verbatim}
Some examples are in the file \verb|examples.exp|.  

For example, once you're done, you will be able to do this to type check
and step through the execution of an expression:
\begin{verbatim}
- Top.loop_step();
Exp>let x be 4 in x + x end;

let x24 be 4 in
    x24 + x24
end : num;

Press return:

4 + 4 : num;

Press return:

8 : num;
\end{verbatim}

You should not change any files other than \ttt{exp-named.sml},
\ttt{check.sml}, and \ttt{step.sml}. We are going to copy these files out
of your handin directory and compile them against the original
versions of the support files; if they don't compile you will get
little credit.

As a general hint, your code should bear an obvious resemblance to the
judgements we have discussed. If you find yourself writing a lot of
code, or code which you can't explain in terms of the judgements, you
are on the wrong track. Don't worry about efficiency; in this
assignment we are concerned only with the correctness and clarity of
your code.

\end{document}
